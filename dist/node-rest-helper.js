// Generated by CoffeeScript 2.0.1
(function() {
  var APIContext, DEFAULT_LIMITS, RateLimiter, RequestBuilder;

  RateLimiter = require('request-rate-limiter');

  // https://developers.facebook.com/docs/graph-api/advanced/rate-limiting

  // Workplace Graph API allowable limits do not work like this, they scale with number of users
  // However, this should provide a healthy safety net in case the app goes crazy with requests
  // and it would take a few minutes of running to burn through even a small instances API limits
  DEFAULT_LIMITS = {
    rate: 20, // requests per interval,
    interval: 10, // interval for the rate, x
    backoffCode: 429, // back off when this status is returned
    backoffTime: 10, // back off for n seconds,
    maxWaitingTime: 120 // return errors for requests that will have to wait for n seconds or more.
  };

  RequestBuilder = RequestBuilder = class RequestBuilder {
    constructor(context, opts) {
      var base, base1, base2, base3;
      this.debug = context.debug;
      this.opts = opts;
      if ((base = this.opts).url == null) {
        base.url = `${context.url}/${this.opts.endpoint}`;
      }
      if ((base1 = this.opts).method == null) {
        base1.method = 'GET';
      }
      if ((base2 = this.opts).headers == null) {
        base2.headers = {};
      }
      if ((base3 = this.opts).qs == null) {
        base3.qs = {};
      }
      this.auth = null;
      this.description = null;
      this.results = [];
      this.nextCursor = null;
      this.firstPage();
    }

    // -----------------------------------------------------------------------------------
    // Set rich description for debug output
    // -----------------------------------------------------------------------------------
    describe(text) {
      //todo: Blank in PROD
      this.description = text;
      return this;
    }

    // -----------------------------------------------------------------------------------
    // Set Bearer {token} authorization header directly
    // Consider using authorizeBy() functions instead which inherit token from context
    // -----------------------------------------------------------------------------------
    setAuthorization(token) {
      if (token.startsWith('Bearer ')) {
        token = token.substr(7);
      }
      return this;
    }

    addHeader(header, value) {
      this.opts.headers[header] = value;
      return this;
    }

    // -----------------------------------------------------------------------------------
    // Set request to authorize by token (will be auto injected from context)
    // -----------------------------------------------------------------------------------
    authorizeByToken() {
      this.auth = 'token';
      return this;
    }

    // -----------------------------------------------------------------------------------
    // Set request to authorize by app id | app secret (will be auto injected from context)
    // -----------------------------------------------------------------------------------
    authorizeByAppSecret() {
      this.auth = 'appsecret';
      return this;
    }

    authorizeByDefault() {
      this.auth = 'default';
      return this;
    }

    authorizeBy(type) {
      this.auth = type;
      return this;
    }

    // -----------------------------------------------------------------------------------
    // Set request to authorize via an impersonation token passed as  {token}
    // See user.getImpersonationToken for details
    // -----------------------------------------------------------------------------------
    impersonate(token) {
      delete this.auth;
      this.setAuthorization(token);
      return this;
    }

    // -----------------------------------------------------------------------------------
    // Shortcut to set an array {fields} as querystring.fields
    // Hint: Many modules export an .ALL_FIELDS property (e.g. user.ALL_FIELDS)
    // -----------------------------------------------------------------------------------
    setFields(fields) {
      if ((fields != null) && Array.isArray(fields) && fields.length > 0) {
        this.opts.qs['fields'] = fields.join(',');
      }
      return this;
    }

    // -----------------------------------------------------------------------------------
    // Shortcut to send the requests json payload
    // -----------------------------------------------------------------------------------
    setJson(json) {
      this.opts.json = json;
      return this;
    }

    // -----------------------------------------------------------------------------------
    // Shortcut to add {key} with {value} to the requests json payload
    // -----------------------------------------------------------------------------------
    addJson(key, value) {
      var base;
      if (value == null) {
        return this;
      }
      if ((base = this.opts).json == null) {
        base.json = {};
      }
      this.opts.json[key] = value;
      return this;
    }

    // -----------------------------------------------------------------------------------
    // Shortcut to set request body
    // -----------------------------------------------------------------------------------
    setBody(body) {
      this.opts.body = body;
      return this;
    }

    // -----------------------------------------------------------------------------------
    // Shortcut to set the request method (GET, POST, DELETE, PUT)
    // -----------------------------------------------------------------------------------
    setMethod(method) {
      if (['GET', 'POST', 'DELETE', 'PUT'].indexOf(method) === -1) {
        throw new Error(`${method} is not a valid request method`);
      }
      this.opts.method = method;
      return this;
    }

    // -----------------------------------------------------------------------------------
    // Shortcut to add/merge {qs} to the requests querystring object
    // e.g. #{ x: 'y', z : 'a'} becomes ?x=y&z=a
    // -----------------------------------------------------------------------------------
    addQueryStringParams(qs) {
      this.opts.qs = Object.assign(this.opts.qs, qs);
      return this;
    }

    // -----------------------------------------------------------------------------------
    // Shortcut to set the requests query string parameters to {qs}
    // -----------------------------------------------------------------------------------
    setQueryStringParams(qs) {
      this.opts.qs = qs;
      return this;
    }

    // -----------------------------------------------------------------------------------
    // Instructs the request to recursively follow any pagination/next cursors returned
    // until {limit} results are reached (default = Infinity). Results are added to an
    // results array on the {aggregationNode property}, usually 'data'

    // WARNING: This uses a recursive implementation which will blow the stack if a large
    // number of pages is returned
    // -----------------------------------------------------------------------------------
    allPages(limit = 2e308, aggregationNode = 'data') {
      this.followNextCursor = true;
      this.resultsLimit = limit;
      this.aggregationNode = aggregationNode;
      return this;
    }

    // -----------------------------------------------------------------------------------
    // Instructions the request to not follow pagination and only return the first page
    // of results. This is the default.
    // -----------------------------------------------------------------------------------
    firstPage() {
      this.followNextCursor = false;
      this.aggregationNode = null;
      return this.resultsLimit = 2e308;
    }

    // -----------------------------------------------------------------------------------
    // Helper function to redact tokens from a message/opts object
    // -----------------------------------------------------------------------------------
    static redactTokens(object) {
      var ref;
      object = JSON.parse(JSON.stringify(object));
      if (object.qs.access_token != null) {
        object.qs.access_token = 'REDACTED';
      }
      if (object.headers.Authorization != null) {
        object.headers.Authorization = 'REDACTED';
      }
      if (((ref = object.json) != null ? ref.verify_token : void 0) != null) {
        object.json.verify_token = 'REDACTED';
      }
      return object;
    }

    // -----------------------------------------------------------------------------------
    // Returns the message with tokens redacted
    // -----------------------------------------------------------------------------------
    toString() {
      var clone;
      clone = RequestBuilder.redactTokens(this);
      return JSON.stringify(clone);
    }

    // -----------------------------------------------------------------------------------
    // set a function to run on results. If the results are a data array (e.g. group/feed)
    // the transform will be applied to each element in the array
    // -----------------------------------------------------------------------------------
    setResultsTransform(func) {
      this.resultsTransform = func;
      return this;
    }

    // -----------------------------------------------------------------------------------
    // Internal: set the next cursor to traverse in a recursive call
    // -----------------------------------------------------------------------------------
    _setNextCursor(cursor) {
      this.nextCursor = cursor;
      return this;
    }

    // -----------------------------------------------------------------------------------
    // Internal: For recursive calls, append more results to the message.
    // -----------------------------------------------------------------------------------
    _addResults(results) {
      if (this.aggregationNode) {
        if (results[this.aggregationNode]) {
          results = results[this.aggregationNode];
        } else {
          throw new Error(`Trying to aggregate results on non existent node ${this.aggregationNode}`);
        }
      }
      if (this.resultsTransform != null) {
        results.map(this.resultsTransform);
      }
      this.debug(`Appending ${results.length} results`);
      //TODO: Strinctly enforce results limit
      this.results = this.results.concat(results);
      return this;
    }

    // -----------------------------------------------------------------------------------
    // Returns a promise to the results of the request, which is immediately sent
    // -----------------------------------------------------------------------------------
    send(context) {
      return RequestBuilder.send(context, this);
    }

    // -----------------------------------------------------------------------------------
    // Send a RequestBuilder object {message} using APIContext {context}
    // -----------------------------------------------------------------------------------
    static send(context, message) {
      var opts;
      context.injectAuthorization(message.auth, message);
      //# Return promise
      opts = JSON.parse(JSON.stringify(message.opts));
      if (message.nextCursor != null) {
        context.debug(`Request has cursor, generating call to ${message.nextCursor}`);
        delete opts.qs;
        delete opts.body;
        delete opts.json;
        opts.url = message.nextCursor;
        delete message.nextCursor;
      }
      context.debug('Sending Request: %o', RequestBuilder.redactTokens(opts));
      opts.resolveWithFullResponse = true;
      return context.limiter.request(opts).then(async function(response) {
        var ref, resp;
        if ((response != null ? response['statusCode'] : void 0) === 200) {
          context.debug(`${message.description} ...  result: ${response['statusCode']}`);
          resp = response['body'];
          if (typeof response['body'] === 'string') {
            resp = JSON.parse(response['body']);
            // Multi response
            // TODO: While this works for most communities,
            // the recursion will blow the stack when there is a very large number
            //       of results. Utilize an async queue to avoid
            if (message.followNextCursor) {
              message._addResults(resp);
              if (((ref = resp['paging']) != null ? ref['next'] : void 0) != null) {
                if (message.results.length < message.resultsLimit) {
                  context.debug(`Received a next cursor ${resp['paging']['cursors']['after']}, following...`);
                  return (await RequestBuilder.send(context, message._setNextCursor(resp['paging'].next)));
                } else {
                  context.debug(`limit (${message.results.length}/${message.resultsLimit}) reached, stopping recursion`);
                  return message.results; //... aannnd we are back from the stack dive
                }
              } else {
                context.debug(`No more cursor, resolving promise with ${message.results.length} total results`);
                return message.results; //# maximum depth, prepare to surface..
              }
            } else {
              if (typeof message.resultsTransform === 'function') {
                resp = message.resultsTransform(resp);
              }
              return resp;
            }
          } else {
            return resp;
          }
        } else {
          throw new Error(`Non 200 status code ${JSON.stringify(response)}`);
        }
      }).catch(function(error) {
        context.debug('Request Error: %o', error);
        throw error;
      });
    }

  };

  module.exports.APIContext = APIContext = class APIContext {
    constructor(name1, load) {
      this.name = name1;
      this.debug = require('debug')(`API:${this.name}`);
      this.debug(`Creating new context ${this.name}`);
      this.authHooks = {};
      this.RequestBuilder = RequestBuilder;
      if (load != null) {
        this.load(load);
      }
    }

    load(api) {
      if (this.loaded) {
        throw new Error('Can only load one extension');
      }
      this.loaded = true;
      this.debug(`Loading ${api.name}, ${api.url}`);
      this.url = api.url;
      if (api.registerExtensions != null) {
        this.registerExtensions(api.registerExtensions(this));
      }
      if (api.authCallbacks) {
        this.registerAuthCallbacks(api.authCallbacks);
      }
      if (api.imports != null) {
        this.loadImports(api.imports);
      }
      this.limiter = new RateLimiter(api.limits || DEFAULT_LIMITS);
      return this;
    }

    registerAuthCallbacks(callbacks) {
      var k, results1, v;
      this.debug('Registering Auth Callbacks');
      results1 = [];
      for (k in callbacks) {
        v = callbacks[k];
        this.authHooks[k] = v;
        results1.push(this.debug(`  ${k} registered`));
      }
      return results1;
    }

    registerExtensions(ext) {
      var k, results1, v;
      this.debug('Registering api extensions');
      results1 = [];
      for (k in ext) {
        v = ext[k];
        this.debug(`  ${k} registered`);
        results1.push(this[k] = v);
      }
      return results1;
    }

    loadImports(imports) {
      var i, key, len, loadedModule, mod, modules, name, value;
      this.debug('Loading helper imports', imports);
      for (key in imports) {
        modules = imports[key];
        this[key] = {};
        for (i = 0, len = modules.length; i < len; i++) {
          mod = modules[i];
          loadedModule = mod(this);
          for (name in loadedModule) {
            value = loadedModule[name];
            this.debug(`  Loaded  ${this.name}.${key}.${name} from ${mod}`);
            this[key][name] = value;
          }
        }
      }
    }

    setAuthCallback(type, fn) {
      this.debug('Setting authorization function');
      if (typeof fn !== 'function') {
        throw new Error('fn must be a function');
      }
      this.authHooks[type] = fn;
    }

    injectAuthorization(type, message) {
      if (this.authHooks[type] == null) {
        throw new Error(`No authorization function ${type} set`);
      }
      return this.authHooks[type](message);
    }

    send(req) {
      return RequestBuilder.send(this, req);
    }

    createCall(opts) {
      return new RequestBuilder({
        url: this.url
      }, opts);
    }

    customCall(CustomClass, opts) {
      return new CustomClass({
        url: this.url
      }, opts);
    }

  };

  module.exports.create = function(name, load) {
    return new APIContext(name, load);
  };

}).call(this);
